脚本是: 
      nohup /mnt/Nand3/H2000G  >/dev/null  2>&1  & 
      对于& 1 更准确的说应该是文件描述符 1,而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO),其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了.其中0 表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。 
      command >out.file  2>&1 & 
      command >out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。 2>&1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个& ， 是让该命令在后台执行。 
      试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出； 
换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出.
      你可以用 
            ls 2>1测试一下，不会报没有2文件的错误，但会输出一个空的文件1； 
            ls xxx 2>1测试，没有xxx这个文件的错误输出到了1中； 
            ls xxx 2>&1测试，不会生成1这个文件了，不过错误跑到标准输出了； 
            ls xxx >out.txt 2>&1, 实际上可换成 ls xxx 1>out.txt 2>&1；重定向符号>默认是1,错误和输出都传到out.txt了。 
      为何2>&1要写在后面？ 
      command > file 2>&1 
       首先是command > file将标准输出重定向到file中， 2>&1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。 
      command 2>&1 >file 
      2>&1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。>file 后输出才被重定向到file，但标准错误仍然保持在终端。
用strace可以看到： 
1. command > file 2>&1 
这个命令中实现重定向的关键系统调用序列是： 
open(file) == 3 
dup2(3,1) 
dup2(1,2)
2. command 2>&1 >file 
这个命令中实现重定向的关键系统调用序列是： 
dup2(1,2) 
open(file) == 3 
dup2(3,1)